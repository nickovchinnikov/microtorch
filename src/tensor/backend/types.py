from abc import ABC, abstractmethod
from collections.abc import Sequence
from enum import Enum
from typing import TypeVar

import numpy as np
from typing_extensions import Protocol, runtime_checkable

Scalar = int | float
Index = int | slice | tuple[int | slice, ...]
Shape = tuple[int, ...]
Dims = int | Shape
Axis = int | tuple[int, ...]

class DType(str, Enum):
    r"""Enum representing supported data types for tensor values."""
    float64 = "float64"
    float32 = "float32"
    int64 = "int64"
    int32 = "int32"
    int16 = "int16"
    int8 = "int8"

Self = TypeVar("Self", bound="Vector")

@runtime_checkable
class Vector(Protocol):
    # --- Metadata ---
    @property
    def shape(self) -> Shape: ...
    @property
    def ndim(self) -> int: ...
    @property
    def size(self) -> int: ...
    @property
    def dtype(self) -> DType: ...
    @property
    def T(self) -> Self: ...

    # --- Indexing ---
    def __getitem__(self, index: Index) -> Self: ...
    def __setitem__(self, index: Index, value: Self | Scalar) -> None: ...

    # --- Creation & Casting ---
    def astype(self, dtype: DType, copy: bool = True) -> Self: ...
    def copy(self) -> Self: ...

    # --- Shape Ops ---
    def reshape(self, shape: Shape) -> Self: ...
    def flatten(self) -> Self: ...
    def squeeze(self, axis: Axis = None) -> Self: ...
    def expand_dims(self, axis: int) -> Self: ...
    def transpose(self, *axes: int) -> Self: ...
    def broadcast_to(self, shape: Shape) -> Self: ...

    # --- Math & Elementwise ---
    def __add__(self, other: Self | Scalar) -> Self: ...
    def __sub__(self, other: Self | Scalar) -> Self: ...
    def __mul__(self, other: Self | Scalar) -> Self: ...
    def __truediv__(self, other: Self | Scalar) -> Self: ...
    def __neg__(self) -> Self: ...
    def __pow__(self, exponent: Self | Scalar) -> Self: ...
    def clip(self, min: Scalar, max: Scalar) -> Self: ...
    def abs(self) -> Self: ...
    def exp(self) -> Self: ...
    def log(self) -> Self: ...
    def sqrt(self) -> Self: ...

    # --- Comparison ---
    def __eq__(self, other: Self | Scalar) -> Self: ...
    def __ne__(self, other: Self | Scalar) -> Self: ...
    def __lt__(self, other: Self | Scalar) -> Self: ...
    def __le__(self, other: Self | Scalar) -> Self: ...
    def __gt__(self, other: Self | Scalar) -> Self: ...
    def __ge__(self, other: Self | Scalar) -> Self: ...

    # --- Reductions ---
    def sum(self, axis: Axis = None, keepdims: bool = False) -> Self: ...
    def mean(self, axis: Axis = None, keepdims: bool = False) -> Self: ...
    def max(self, axis: Axis = None, keepdims: bool = False) -> Self: ...
    def min(self, axis: Axis = None, keepdims: bool = False) -> Self: ...
    def argmax(self, axis: int = None) -> Self: ...
    def argmin(self, axis: int = None) -> Self: ...

    # --- Logical & Indexing ---
    def any(self, axis: Axis = None, keepdims: bool = False) -> Self: ...
    def all(self, axis: Axis = None, keepdims: bool = False) -> Self: ...
    def nonzero(self) -> tuple[Self, ...]: ...

    # --- Conversion ---
    def item(self) -> Scalar: ...
    def tolist(self) -> list: ...
    def __array__(self, dtype: DType = None) -> object: ...

class Linalg(Protocol):
    def norm(
        self,
        x: Vector,
        ord: int | float | str = None,
        axis: Axis = None,
        keepdims: bool = False,
    ) -> Scalar: ...

    def inv(self, x: Vector) -> Vector: ...

    def det(self, x: Vector) -> Scalar: ...

    def svd(
        self,
        x: Vector,
        full_matrices: bool = True,
        compute_uv: bool = True,
        hermitian: bool = False
    ) -> tuple[Vector, ...]: ...

    def eig(self, x: Vector) -> tuple[Vector, Vector]: ...

    def eigh(
        self,
        x: Vector,
        UPLO: str = "L"
    ) -> tuple[Vector, Vector]: ...

    def qr(
        self,
        x: Vector,
        mode: str = "reduced"
    ) -> tuple[Vector, Vector]: ...

    def solve(
        self,
        a: Vector,
        b: Vector
    ) -> Vector: ...

    def lstsq(
        self,
        a: Vector,  
        b: Vector,
        rcond: float | None = None
    ) -> tuple[Vector, Vector, int, Vector]: ...

    def matrix_power(
        self,
        x: Vector,
        n: int
    ) -> Vector: ...

class Backend(ABC):
    # === Tensor creation and conversion ===
    @abstractmethod
    def array(self, data: Sequence | Vector, dtype: DType | None = None) -> Vector: ...
    @abstractmethod
    def zeros_like(self, a: Vector, dtype: DType | None = None) -> Vector: ...
    @abstractmethod
    def ones_like(self, a: Vector, dtype: DType | None = None) -> Vector: ...
    @abstractmethod
    def copy(self, a: Vector) -> Vector: ...
    @abstractmethod
    def astype(self, a: Vector, dtype: DType) -> Vector: ...
    @abstractmethod
    def from_numpy(self, a: np.ndarray) -> Vector: ...
    @abstractmethod
    def to_numpy(self, a: Vector) -> np.ndarray: ...

    # === Elementwise operations ===
    @abstractmethod
    def add(self, a: Vector, b: Scalar | Vector) -> Vector: ...
    @abstractmethod
    def subtract(self, a: Vector, b: Scalar | Vector) -> Vector: ...
    @abstractmethod
    def multiply(self, a: Vector, b: Scalar | Vector) -> Vector: ...
    @abstractmethod
    def true_divide(self, a: Vector, b: Scalar | Vector) -> Vector: ...
    @abstractmethod
    def pow(self, a: Vector, exponent: Scalar | Vector) -> Vector: ...
    @abstractmethod
    def abs(self, a: Vector) -> Vector: ...
    @abstractmethod
    def exp(self, a: Vector) -> Vector: ...
    @abstractmethod
    def log(self, a: Vector) -> Vector: ...
    @abstractmethod
    def tanh(self, a: Vector) -> Vector: ...
    @abstractmethod
    def clip(self, a: Vector, min_value: Scalar, max_value: Scalar) -> Vector: ...

    # === Comparison ===
    @abstractmethod
    def equal(self, a: Vector, b: Scalar | Vector) -> Vector: ...
    @abstractmethod
    def not_equal(self, a: Vector, b: Scalar | Vector) -> Vector: ...
    @abstractmethod
    def greater(self, a: Vector, b: Scalar | Vector) -> Vector: ...
    @abstractmethod
    def greater_equal(self, a: Vector, b: Scalar | Vector) -> Vector: ...
    @abstractmethod
    def less(self, a: Vector, b: Scalar | Vector) -> Vector: ...
    @abstractmethod
    def less_equal(self, a: Vector, b: Scalar | Vector) -> Vector: ...

    # === Reduction ===
    @abstractmethod
    def sum(self, a: Vector, axis: Axis = None, keepdims: bool = False) -> Vector: ...
    @abstractmethod
    def mean(self, a: Vector, axis: Axis = None, keepdims: bool = False) -> Vector: ...
    @abstractmethod
    def max(self, a: Vector, axis: Axis = None, keepdims: bool = False) -> Vector: ...
    @abstractmethod
    def min(self, a: Vector, axis: Axis = None, keepdims: bool = False) -> Vector: ...

    # === Shape manipulation ===
    @abstractmethod
    def reshape(self, a: Vector, shape: Shape) -> Vector: ...
    @abstractmethod
    def transpose(self, a: Vector, axes: Axis | None = None) -> Vector: ...
    @abstractmethod
    def broadcast_to(self, a: Vector, shape: Shape) -> Vector: ...
    @abstractmethod
    def expand_dims(self, a: Vector, axis: int) -> Vector: ...
    @abstractmethod
    def squeeze(self, a: Vector, axis: Axis | None = None) -> Vector: ...

    # === Indexing ===
    @abstractmethod
    def where(self, condition: Vector, a: Vector, b: Vector) -> Vector: ...

    # === Random generation ===
    @abstractmethod
    def random_uniform(self, low: Scalar, high: Scalar, shape: Shape) -> Vector: ...
    @abstractmethod
    def random_normal(self, mean: Scalar, std: Scalar, shape: Shape) -> Vector: ...

    # === Linear algebra ===
    @property
    @abstractmethod
    def linalg(self) -> Linalg: ...

    # === Type info ===
    @property
    @abstractmethod
    def name(self) -> str: ...
    @property
    @abstractmethod
    def ndarray(self) -> type: ...
